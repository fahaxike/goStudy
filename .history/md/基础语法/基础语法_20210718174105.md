<!-- TOC -->

- [基础语法结构](#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84)
    - [go语言背景](#go%E8%AF%AD%E8%A8%80%E8%83%8C%E6%99%AF)
    - [环境安装](#%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85)
        - [安装go开发包](#%E5%AE%89%E8%A3%85go%E5%BC%80%E5%8F%91%E5%8C%85)
            - [windows安装](#windows%E5%AE%89%E8%A3%85)
                - [安装软件](#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6)
                - [配置环境变量](#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)
                - [更改go环境配置](#%E6%9B%B4%E6%94%B9go%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE)
                - [安装go插件](#%E5%AE%89%E8%A3%85go%E6%8F%92%E4%BB%B6)
                - [安装go语言工具包](#%E5%AE%89%E8%A3%85go%E8%AF%AD%E8%A8%80%E5%B7%A5%E5%85%B7%E5%8C%85)
    - [基础知识](#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86)
        - [包概念](#%E5%8C%85%E6%A6%82%E5%BF%B5)
        - [标识符](#%E6%A0%87%E8%AF%86%E7%AC%A6)
        - [变量](#%E5%8F%98%E9%87%8F)
            - [变量的功能](#%E5%8F%98%E9%87%8F%E7%9A%84%E5%8A%9F%E8%83%BD)
            - [变量声明以及初始化](#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%BB%A5%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96)
        - [常量](#%E5%B8%B8%E9%87%8F)
            - [iota](#iota)
    - [语法](#%E8%AF%AD%E6%B3%95)
        - [if](#if)
        - [for](#for)
        - [switch](#switch)
    - [数据结构](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
        - [基础数据类型](#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)
            - [int](#int)
            - [float](#float)
            - [bool](#bool)
            - [string](#string)
            - [string常用包](#string%E5%B8%B8%E7%94%A8%E5%8C%85)
            - [数据类型转换](#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2)
                - [整数浮点数数据转换](#%E6%95%B4%E6%95%B0%E6%B5%AE%E7%82%B9%E6%95%B0%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2)
                - [其他转string](#%E5%85%B6%E4%BB%96%E8%BD%ACstring)
                - [string转其他](#string%E8%BD%AC%E5%85%B6%E4%BB%96)
        - [运算符](#%E8%BF%90%E7%AE%97%E7%AC%A6)
            - [算术运算符](#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6)
            - [关系运算符](#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6)
            - [逻辑运算符](#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6)
            - [位运算符](#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6)
            - [赋值运算符](#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6)
        - [数组 array](#%E6%95%B0%E7%BB%84-array)
            - [数组初始化方式](#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F)
            - [数组传值](#%E6%95%B0%E7%BB%84%E4%BC%A0%E5%80%BC)
        - [切片 slice](#%E5%88%87%E7%89%87-slice)
            - [切片声明和初始化](#%E5%88%87%E7%89%87%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96)
            - [切片扩容](#%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9)
        - [映射 map](#%E6%98%A0%E5%B0%84-map)
        - [指针](#%E6%8C%87%E9%92%88)
        - [结构体 struct](#%E7%BB%93%E6%9E%84%E4%BD%93-struct)
        - [接口 interface](#%E6%8E%A5%E5%8F%A3-interface)
        - [管道 channel](#%E7%AE%A1%E9%81%93-channel)
        - [协程 goroutine](#%E5%8D%8F%E7%A8%8B-goroutine)
    - [总结](#%E6%80%BB%E7%BB%93)

<!-- /TOC -->
# 基础语法结构
## go语言背景
1. Google公司开发  
2. 编译型语言  
   语言分为编译型语言和解释型语言  
   - 解释性语言 源码->(虚拟机)解释器->处理器  
   - 编译型语言 源码->处理器  
   - 解释器处理的是字节码文件，处理器处理的是二进制文件
3. 语言特性  
      - 语法简单  
   - 开发效率高 自带垃圾回收
   - 天生支持高并发    
## 环境安装 
### 安装go开发包  
安装地址   
Go官网下载地址：https://golang.org/dl/  
Go官方镜像站（推荐）：https://golang.google.cn/dl/
#### windows安装  
##### 安装软件
![安装路径](2021-07-07-23-58-21.png)  
安装路径 
安装路径尽量选择一个简单的路径，这个路径也就是下面的GOROOT路径

查看安装是否成功 ，打开cmd 输入`go version` 查看
![](2021-07-08-00-02-04.png)  
go version 结果
##### 配置环境变量  
创建gopath文件夹 并在下面新建bin,pkg,src 三个文件夹 
![](2021-07-08-00-06-15.png)

增加环境变量  
![](2021-07-08-01-06-17.png)  
path
![](2021-07-08-01-06-48.png)  
gopath  
![](2021-07-08-01-09-03.png)
goroot

配置完之后，另开一个cmd用`go env`  查看  
![](2021-07-08-01-15-36.png)
发现已经生效 
##### 更改go环境配置 
1. 更改GO111MODULE  参考 https://blog.csdn.net/yptsqc/article/details/105270530
go编译程序时，go path -> go root ,在1.11版本之后，使用go module管理依赖，使用 go module管理之后会在项目的根目录下面生成 go.mod 和go.sum俩个文件 ，go.mod会记录当前项目的所有依赖，go.sum会记录依赖的哈希值，示例如下  
![](2021-07-08-01-35-03.png) 


修改配置`go env -w GO111MODULE=on`  
使用go module 创建一个新项目  
`go mod init project名称`  
在原有项目下使用 go module  
`go mod init .` 
在程序运行go build时会将项目中的依赖添加到go.mod

2. 修改指定代理服务地址
`go env -w GOPROXY=https://goproxy.cn,direct`  
##### 安装go插件   
![](2021-07-08-01-53-53.png)  
##### 安装go语言工具包 
这些工具包主要包括自动补全，代码提示等功能  
按ctrl+shift+p 在命令行  go:install 选在 Go:Install/Update Tools 选择所有确定   
![](2021-07-08-02-09-55.png)
在修改了上述的代理配置之后，会发现所有的相关工具包都安装成功，接下来lets go  
## 基础知识 
### 包概念  
1. 每一个.go原文件非注释第一行都应该包含一个包名，关键字 package  
2. 每一个.go文件只属于一个包，一个包可以包含多个go文件   
3. main 包编译成一个可执行程序 
4. 如果非main包会被编译成.a文件 ，所有的包名都应该是小写 
5. 通过 import关键字进行包导入  写法 import("fmt";"os")  
6. 这里面import导入的实际是一个目录  ，一个目录下面只允许有一个包名，这个包名可以和目录名不一致，一般情况下包名都和目录名保持一致。
7. ![](2021-07-16-11-18-10.png)  
8. ![](2021-07-16-11-24-05.png)
9. 编译顺序：如果a依赖b，b依赖c,则编译顺序 c,b,a  
10. 依赖第三方库编译时，需要源码，链接指向最新源码编译的临时目录的.a文件  
11. 依赖标准库编译时，也需要源码，但是标准库源码不会重新编译，只是在连接时链接已经编译好的.a文件
```
package main

import (
	hh "goStudy/src/base"//给包起别名
	_ "fmt" //引用包但不调用
)

func main() {
	hh.Printfmt()

}
```  
### 标识符  
函数的外面只能放置标识符声明(变量、常量、函数、类型)  
标识符的声明规则  

- 标识符可以有数字字母下划线组成  
- 只能以字母或者下划线开头  
- 不能和关键字以及预留标识符冲突  
- 严格区分大小写 
- _作为空标识符，忽略对应值 
- 一般采用驼峰命名法  
### 变量  
#### 变量的功能  
变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。  
#### 变量声明以及初始化 
变量声明的格式 
```
var 变量名  变量类型  
var 变量名  变量类型  = 值
var 变量名  = 值
变量名  := 值

````

```
//单独声明
// var name int
// var age string
// var isOk bool

//一起声明
var (
	name string
	age  int
	isOk bool
)

//全局变量可以声明不使用，但是函数内的变量必须声明
func Printfmt() {
	//变量初始化
	name = "xiao名"
	age = 18
	isOk = false
	fmt.Println(isOk)
	fmt.Printf("name = %s,age=%v,isOk=%v\r\n", name, age, isOk)
	//变量初始话
	var s1 string = "hehe"
	fmt.Println(s1)
	//类型推导
	var s2 = "haha"
	fmt.Println(s2)
	//简短声明，只能在函数中使用
	s3 := "heihei"
	fmt.Println(s3)

}
```  
变量初始值 
- 整形浮点型的默认值为0
- string 默认值为 空字符串
- bool默认为 false 
- 切片，指针，函数默认初始值nil

### 常量 
常量是恒定不变的值
常量声明  `const 常量名 = 常量值` 
#### iota  
iota是go语言的常量计数器，只能在常量的表达式中使用，在const出现时被置为0，const中每新增一行常量声明。iota计数一次 
```
const a = 100
const (
	a1 = 100
	a2
	a3
	a4 = iota //3
)
const (
	b1 = 100
	b2 = iota //1
	b3        //2
	b4 = 101  //101
	b5        //101
	b6 = iota //5
)
const (
	_  = iota
	KB = 1 << (10 * iota)
	MB = 1 << (10 * iota)
	GB = 1 << (10 * iota)
	TB = 1 << (10 * iota)
)

//全局变量可以声明不使用，但是函数内的变量必须声明
func PrintCon() {

	fmt.Println("a1:", a1)
	fmt.Println("a2:", a2)
	fmt.Println("a3:", a3)
	fmt.Println("a4:", a4)
	fmt.Println("b1:", b1) //100
	fmt.Println("b2:", b2) //1
	fmt.Println("b3:", b3) //2
	fmt.Println("b4:", b4) //101
	fmt.Println("b5:", b5)
	fmt.Println("b6:", b6)

}
-------------------------------------------------------------
a1: 100
a2: 100
a3: 100
a4: 3
b1: 100
b2: 1
b3: 2
b4: 101
b5: 101
b6: 5
```




## 语法 
### if
两种写法 
```
i := 5
	if i <= 5 {
		fmt.Println("i大于5")

	} else if i < 10 {
		fmt.Println("i大于5小于10")
	} else {
		fmt.Println("i大于等于10")
	}
	fmt.Println("---------------------------------------")
	if i := 6; i > 5 {
		fmt.Println("i大于5")

	} else if i < 10 {
		fmt.Println("i大于5小于10")
	} else {
		fmt.Println("i大于等于10")
	}
``` 
### for 
三种for写法 ，for range 
```
for i := 1; i < 10; i++ {
		fmt.Println(i)
	}
	fmt.Println("---------------------------------------")
	for ; i < 10; i++ {
		fmt.Println(i)
	}
	fmt.Println("---------------------------------------")
	for i < 10 {
		fmt.Println(i)
		i++
	}
	fmt.Println("---------------------------------------")
	fmt.Println(i)

	a := []byte{'a', 'b', 'c', 'd'}
	for k, v := range a {
		fmt.Printf("key:%v value:%c", k, v)
	}
```
### switch 
两种写法 
```
switch i {
	case 5:
		fmt.Println("i=5")
	case 6:
		fmt.Println("i=6")
	case 10:
		fmt.Println("i=10")
		fallthrough

	case 11:
		fmt.Println("i=11")
	case 12:
		fmt.Println("i=12")
	default:
		fmt.Println("其他")

	}
	fmt.Println("---------------------------------------")
	switch {
	case i < 5:
		fmt.Println("i=5")

	case i >= 10:
		fmt.Println("i>=10")
		fallthrough
	default:
		fmt.Println("其他")

	}
```

## 数据结构  
### 基础数据类型  
#### int 
| 类型   | 范围                           | 内存大小             |
|--------|--------------------------------|----------------------|
| int8   | 0~2^8-1(0~255)                 | 1                    |
| int16  | 0~2^16-1(0~65535)              | 2                    |
| int32  | 0~2^32-1(0~4294967295)         | 4                    |
| int64  | 0~2^64(0~18446744073709551615) | 8                    |
| uint8  | (-127~127)                     | 1                    |
| uint16 | (-32767~32767)                 | 2                    |
| uint32 | (-2147483648~2147483648)       | 4                    |
| uint64 |                                | 8                    |
| int    |                                | 根据系统位数自动定位 |
| uint   |                                | 根据系统位数自动定位 |

```
func main() {
	i := 20
	fmt.Printf("i1类型%T\n", i)
	fmt.Printf("i1二进制%b\n", i)
	fmt.Printf("i1十进制%d\n", i)
	fmt.Printf("i1八进制%o\n", i)
	fmt.Printf("i1十六进制%x\n", i)
	i2 := 011
	fmt.Printf("i2类型%T\n", i2)
	fmt.Printf("i2二进制%b\n", i2)
	fmt.Printf("i2十进制%d\n", i2)
	fmt.Printf("i2八进制%o\n", i2)
	fmt.Printf("i2十六进制%x\n", i2)
	i3 := 0x11
	fmt.Printf("i3类型%T\n", i3)
	fmt.Printf("i3二进制%b\n", i3)
	fmt.Printf("i3十进制%d\n", i3)
	fmt.Printf("i3八进制%o\n", i3)
	fmt.Printf("i3十六进制%x\n", i3)

	i4 := int32(i)
	fmt.Printf("i4类型%T\n", i4)
	fmt.Printf("i4二进制%b\n", i4)
	fmt.Printf("i4十进制%d\n", i4)
	fmt.Printf("i4八进制%o\n", i4)
	fmt.Printf("i4十六进制%x\n", i4)
	//字面量语法
	i5 := 0b10011
	fmt.Printf("i5类型%T\n", i5)
	fmt.Printf("i5二进制%b\n", i5)
	fmt.Printf("i5十进制%d\n", i5)
	fmt.Printf("i5八进制%o\n", i5)
	fmt.Printf("i5十六进制%x\n", i5)
	//字面量语法
	i6 := 0o11
	fmt.Printf("i6类型%T\n", i6)
	fmt.Printf("i6二进制%b\n", i6)
	fmt.Printf("i6十进制%d\n", i6)
	fmt.Printf("i6八进制%o\n", i6)
	fmt.Printf("i6十六进制%x\n", i6)
	//字面量语法
	i7 := 0x11
	fmt.Printf("i7类型%T\n", i7)
	fmt.Printf("i7二进制%b\n", i7)
	fmt.Printf("i7十进制%d\n", i7)
	fmt.Printf("i7八进制%o\n", i7)
	fmt.Printf("i7十六进制%x\n", i7)
}
----------------------------------------------------------
i1类型int
i1二进制10100
i1十进制20
i1八进制24
i1十六进制14
i2类型int
i2二进制1001
i2十进制9
i2八进制11
i2十六进制9
i3类型int
i3二进制10001
i3十进制17
i3八进制21
i3十六进制11
i4类型int32
i4二进制10100
i4十进制20
i4八进制24
i4十六进制14
i5类型int
i5二进制10011
i5十进制19
i5八进制23
i5十六进制13
i6类型int
i6二进制1001
i6十进制9
i6八进制11
i6十六进制9
i7类型int
i7二进制10001
i7十进制17
i7八进制21
i7十六进制11

```
#### float  
| 类型    | 范围                 | 内存大小 |
|---------|----------------------|----------|
| float32 | -3.403e38~3.403e38   | 4        |
| float64 | -1.798e308~1.798e308 | 8        |

#### bool
| 类型 | 范围  | 内存大小 |
|------|-------|----------|
| bool | true  | 1        |
| bool | false | 1        |
- bool值默认为false  
- go中不允许将整形转成bool型 
- 布尔型无法参与数值运算，也无法与其他类型进行转换
#### string   
  字符串是由字符组成一个串。  
  字符串不可变，想改变某个字符需要转换成byte切片或者rune切片。
  字符串特殊字符可以用转义字符表示，也可以用``来表示，不需要转义
  字符串拼接用+或者+=，一个字符串过长换行时+需要放在上一行。
  byte本质上是uint8,rune本质上是int32,一个汉字一般占3个字节 
#### string常用包 
len(str)	求长度
+或fmt.Sprintf	拼接字符串
strings.Split	分割
strings.contains	判断是否包含
strings.HasPrefix,strings.HasSuffix	前缀/后缀判断
strings.Index(),strings.LastIndex()	子串出现的位置
strings.Join(a[]string, sep string)	join操作

#### 数据类型转换 
 ##### 整数浮点数数据转换  
 - go语言不存隐式转换，所有的类型转换都需要显式转换  
 - 转换的时候，会有溢出现象，但不会报错  
 ##### 其他转string  
 ```//int2str
	i1 := 55
	s1 := fmt.Sprintf("%d", i1)
	//float2str
	f1 := 5.5555
	ss1 := fmt.Sprintf("%.3f", f1)
	fmt.Printf("s1 %T value %s ;ss1 %T value %s\n", s1, s1, ss1, ss1)
	s2 := strconv.Itoa(i1)
	ss2 := strconv.FormatFloat(f1, 'f', 3, 64)
	fmt.Printf("s2 %T value %s; ss2 %T value %s\n", s2, s2, ss2, ss2)
	//bool2str
	b1 := true
	sb1 := fmt.Sprintf("%t", b1)
	ssb1 := strconv.FormatBool(b1)
	fmt.Printf("sb1 %T value %s; ssb1 %T value %s\n", sb1, sb1, ssb1, ssb1)
	-----------------------------------------------------------------------
	s1 string value 55 ;ss1 string value 5.556
	s2 string value 55; ss2 string value 5.556
	sb1 string value true; ssb1 string value true
 ```
 ##### string转其他  
 ```
 	s1 := "55"
	s2 := "55.5556"
	s3 := "true"
	i1, _ := strconv.Atoi(s1)
	ii1, _ := strconv.ParseInt(s1, 16, 64)
	f2, _ := strconv.ParseFloat(s2, 64)
	b3, _ := strconv.ParseBool(s3)
	fmt.Printf("i1 %T value %v; \n", i1, i1)
	fmt.Printf("ii1 %T value %v; \n", ii1, ii1)
	fmt.Printf("f2 %T value %v; \n", f2, f2)
	fmt.Printf("b3 %T value %v; \n", b3, b3)
	----------------------------------------
	i1 int value 55; 
	ii1 int64 value 85; 
	f2 float64 value 55.5556;
	b3 bool value true;
```  
### 运算符  

#### 算术运算符
| 运算符 | 描述 |
|--------|------|
| +      | 相加 |
| -      | 相减 |
| *      | 相乘 |
| /      | 相除 |
| %      | 求余 |
| ++     | 加加 |
| --     | 减减 |
#### 关系运算符
| 运算符 | 描述                                                           |
|--------|----------------------------------------------------------------|
| ==     | 检查两个值是否相等，如果相等返回 True 否则返回 False。         |
| !=     | 检查两个值是否不相等，如果不相等返回 True 否则返回 False。     |
| >      | 检查左边值是否大于右边值，如果是返回 True 否则返回 False。     |
| >=     | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 |
| <      | 检查左边值是否小于右边值，如果是返回 True 否则返回 False。     |
| <=     | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 |
#### 逻辑运算符
| 运算符 | 描述                                                                    |
|--------|-------------------------------------------------------------------------|
| &&     | 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。  |
| \|\|   | 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。 |
| !      | 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。            |
#### 位运算符
| 运算符 | 描述                                                                                      |
|--------|-------------------------------------------------------------------------------------------|
| &      | 参与运算的两数各对应的二进位相与。 （两位均为1才为1）                                     |
| \|     | 参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）                                 |
| ^      | 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1） |
| <<     | 左移n位就是乘以2的n次方。 “a<<b”是把a的各二进位全部左移b位，高位丢弃，低位补0。           |
| >>     | 右移n位就是除以2的n次方。 “a>>b”是把a的各二进位全部右移b位。                              |
#### 赋值运算符
| 运算符 | 描述                                           |
|--------|------------------------------------------------|
| =      | 简单的赋值运算符，将一个表达式的值赋给一个左值 |
| +=     | 相加后再赋值                                   |
| -=     | 相减后再赋值                                   |
| *=     | 相乘后再赋值                                   |
| /=     | 相除后再赋值                                   |
| %=     | 求余后再赋值                                   |
| <<=    | 左移后赋值                                     |
| >>=    | 右移后赋值                                     |
| &=     | 按位与后赋值                                   |
| \|=    | 按位或后赋值                                   |
| ^=     | 按位异或后赋值                                 |
### 数组 array
  - 数组是值类型，在声明是就确定了。在使用时可以修改
  - 数组的长度必须是常量，并且长度是数组类型的一部分，[3]int 和[4]int 是两个类型
  - [n]*T为指针数组 *[n]T为数组指针
  - 数组支持= ！=运算符
  数组的定义`var 变量名 [长度]数据类型`  
  #### 数组初始化方式  
    - 使用初始化列表初始化
    - 提供初始值，编译器自动推断出数组长度
    - 指定索引值初始化
  #### 数组传值
  ```
  func main() {

	var a0 [3]int = [3]int{1, 2, 3}
	fmt.Printf("type:%T value:%v\n", a0, a0)
	var a1 = [3]int{1, 2, 3}
	fmt.Printf("type:%T value:%v\n", a1, a1)
	a2 := [3]int{1, 2, 3}
	fmt.Printf("type:%T value:%v\n", a2, a2)
	var a3 = [...]int{1, 2, 3, 4}
	fmt.Printf("type:%T value:%v\n", a3, a3)
	var a4 = [...]int{1: 2, 3: 4}
	fmt.Printf("type:%T value:%v\n", a4, a4)
	fmt.Printf("a1等于 a2 is:%v\n", a1 == a2)
	fmt.Printf("a4等于 a3 is:%v\n", a4 == a3)
	modify1(a1)
	fmt.Printf("type:%T value:%v\n", a1, a1)
	modify2(&a2)
	fmt.Printf("type:%T value:%v\n", a2, a2)

}

func modify1(a [3]int) [3]int {
	fmt.Println(a)
	a[0] = 10
	fmt.Println(a)
	return a
}
func modify2(a *[3]int) [3]int {
	fmt.Println(a)
	a[0] = 10
	fmt.Println(a)
	return *a
}
-----------------------------------
type:[3]int value:[1 2 3]
type:[3]int value:[1 2 3]
type:[3]int value:[1 2 3]
type:[4]int value:[1 2 3 4]
type:[4]int value:[0 2 0 4]
a1等于 a2 is:true
a4等于 a3 is:false
[1 2 3]
[10 2 3]
type:[3]int value:[1 2 3]
&[1 2 3]
&[10 2 3]
type:[3]int value:[10 2 3]
```
### 切片 slice
切片是拥有相同类型元素的可变长度的序列，切片是对数组的一个层封装，
切片是引用类型，结构由：地址，长度，容量三部分组成，地址指向底层数组的头部地址
![](2021-07-18-14-57-35.png)
![](2021-07-18-14-57-58.png)
#### 切片声明和初始化
切片声明 `var 变量名 []切片类型`
切片表达式 
```
var a1 = [3]int{0, 1, 3}
	s1 := a1[:2]  //第一个元素:高索引
	s2 := a1[1:2] //低索引：高索引
	s3 := a1[1:]  //
	s4 := a1[:]
	s5 := s3[:2]
	var s6 []int
	s6 = a1[0:1:3]
	fmt.Printf("type:%T value:%v\n", a1, a1)
	fmt.Printf("type:%T value:%v,len:=%v,cap:%v,ptr:%p\n", s1, s1, len(s1), cap(s1), s1)
	fmt.Printf("type:%T value:%v,len:=%v,cap:%v,ptr:%p\n", s2, s2, len(s2), cap(s2), s2)
	fmt.Printf("type:%T value:%v,len:=%v,cap:%v,ptr:%p\n", s3, s3, len(s3), cap(s3), s3)
	fmt.Printf("type:%T value:%v,len:=%v,cap:%v,ptr:%p\n", s4, s4, len(s4), cap(s4), s4)
	fmt.Printf("type:%T value:%v,len:=%v,cap:%v,ptr:%p\n", s5, s5, len(s5), cap(s5), s5)
	fmt.Printf("type:%T value:%v,len:=%v,cap:%v,ptr:%p\n", s6, s6, len(s6), cap(s6), s6)
	var s7 = make([]int, 3, 5)
	fmt.Printf("type:%T value:%v,len:=%v,cap:%v,ptr:%p\n", s7, s7, len(s7), cap(s7), s7)
	------------------------------------------------
	type:[3]int value:[0 1 3]
	type:[]int value:[0 1],len:=2,cap:3,ptr:0xc0000ae090
	type:[]int value:[1],len:=1,cap:2,ptr:0xc0000ae098
	type:[]int value:[1 3],len:=2,cap:2,ptr:0xc0000ae098
	type:[]int value:[0 1 3],len:=3,cap:3,ptr:0xc0000ae090
	type:[]int value:[1 3],len:=2,cap:2,ptr:0xc0000ae098
	type:[]int value:[0],len:=1,cap:3,ptr:0xc0000ae090
	type:[]int value:[0 0 0],len:=3,cap:5,ptr:0xc0000d6030
```

#### 切片扩容
  1. 当追加的元素个数大于当前容量是，新容量=旧容量+新容量
切片只要扩容，那么就将底层数组就将指向一个新内存的地址，不再与原来的底层数组共享内存


### 映射 map
### 指针
### 结构体 struct 
### 接口 interface 
### 管道 channel
### 协程 goroutine
## 总结 






 


    

  
