# 基础语法结构
## go语言背景
1. Google公司开发  
2. 编译型语言  
   语言分为编译型语言和解释型语言  
   - 解释性语言 源码->(虚拟机)解释器->处理器  
   - 编译型语言 源码->处理器  
   - 解释器处理的是字节码文件，处理器处理的是二进制文件
3. 语言特性  
      - 语法简单  
   - 开发效率高 自带垃圾回收
   - 天生支持高并发    
## 环境安装 
### 安装go开发包  
安装地址   
Go官网下载地址：https://golang.org/dl/  
Go官方镜像站（推荐）：https://golang.google.cn/dl/
#### windows安装  
##### 安装软件
![安装路径](2021-07-07-23-58-21.png)  
安装路径 
安装路径尽量选择一个简单的路径，这个路径也就是下面的GOROOT路径

查看安装是否成功 ，打开cmd 输入`go version` 查看
![](2021-07-08-00-02-04.png)  
go version 结果
##### 配置环境变量  
创建gopath文件夹 并在下面新建bin,pkg,src 三个文件夹 
![](2021-07-08-00-06-15.png)

增加环境变量  
![](2021-07-08-01-06-17.png)  
path
![](2021-07-08-01-06-48.png)  
gopath  
![](2021-07-08-01-09-03.png)
goroot

配置完之后，另开一个cmd用`go env`  查看  
![](2021-07-08-01-15-36.png)
发现已经生效 
##### 更改go环境配置 
1. 更改GO111MODULE  参考 https://blog.csdn.net/yptsqc/article/details/105270530
go编译程序时，go path -> go root ,在1.11版本之后，使用go module管理依赖，使用 go module管理之后会在项目的根目录下面生成 go.mod 和go.sum俩个文件 ，go.mod会记录当前项目的所有依赖，go.sum会记录依赖的哈希值，示例如下  
![](2021-07-08-01-35-03.png) 


修改配置`go env -w GO111MODULE=on`  
使用go module 创建一个新项目  
`go mod init project名称`  
在原有项目下使用 go module  
`go mod init .` 
在程序运行go build时会将项目中的依赖添加到go.mod

2. 修改指定代理服务地址
`go env -w GOPROXY=https://goproxy.cn,direct`  
##### 安装go插件   
![](2021-07-08-01-53-53.png)  
##### 安装go语言工具包 
这些工具包主要包括自动补全，代码提示等功能  
按ctrl+shift+p 在命令行  go:install 选在 Go:Install/Update Tools 选择所有确定   
![](2021-07-08-02-09-55.png)
在修改了上述的代理配置之后，会发现所有的相关工具包都安装成功，接下来lets go  
## 基础知识 
### 包概念  
1. 每一个.go原文件非注释第一行都应该包含一个包名，关键字 package  
2. 每一个.go文件只属于一个包，一个包可以包含多个go文件   
3. main 包编译成一个可执行程序 
4. 如果非main包会被编译成.a文件 ，所有的包名都应该是小写 
5. 通过 import关键字进行包导入  写法 import("fmt";"os")  
6. 这里面import导入的实际是一个目录  ，一个目录下面只允许有一个包名，这个包名可以和目录名不一致，一般情况下包名都和目录名保持一致。
7. ![](2021-07-16-11-18-10.png)  
8. ![](2021-07-16-11-24-05.png)
9. 编译顺序：如果a依赖b，b依赖c,则编译顺序 c,b,a  
10. 依赖第三方库编译时，需要源码，链接指向最新源码编译的临时目录的.a文件  
11. 依赖标准库编译时，也需要源码，但是标准库源码不会重新编译，只是在连接时链接已经编译好的.a文件
```
package main

import (
	hh "goStudy/src/base"//给包起别名
	_ "fmt" //引用包但不调用
)

func main() {
	hh.Printfmt()

}
```  
### 标识符  
函数的外面只能放置标识符声明(变量、常量、函数、类型)  
标识符的声明规则  

- 标识符可以有数字字母下划线组成  
- 只能以字母或者下划线开头  
- 不能和关键字以及预留标识符冲突  
- 严格区分大小写 
- _作为空标识符，忽略对应值 
- 一般采用驼峰命名法  
### 变量  
#### 变量的功能  
变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。  
#### 变量声明以及初始化 
变量声明的格式 
```
var 变量名  变量类型  
var 变量名  变量类型  = 值
var 变量名  = 值
变量名  := 值

````

```
//单独声明
// var name int
// var age string
// var isOk bool

//一起声明
var (
	name string
	age  int
	isOk bool
)

//全局变量可以声明不使用，但是函数内的变量必须声明
func Printfmt() {
	//变量初始化
	name = "xiao名"
	age = 18
	isOk = false
	fmt.Println(isOk)
	fmt.Printf("name = %s,age=%v,isOk=%v\r\n", name, age, isOk)
	//变量初始话
	var s1 string = "hehe"
	fmt.Println(s1)
	//类型推导
	var s2 = "haha"
	fmt.Println(s2)
	//简短声明，只能在函数中使用
	s3 := "heihei"
	fmt.Println(s3)

}
```  
变量初始值 
- 整形浮点型的默认值为0
- string 默认值为 空字符串
- bool默认为 false 
- 切片，指针，函数默认初始值nil

### 常量 
常量是恒定不变的值
常量声明  `const 常量名 = 常量值` 
#### iota  
iota是go语言的常量计数器，只能在常量的表达式中使用，在const出现时被置为0，const中每新增一行常量声明。iota计数一次 
```
const a = 100
const (
	a1 = 100
	a2
	a3
	a4 = iota //3
)
const (
	b1 = 100
	b2 = iota //1
	b3        //2
	b4 = 101  //101
	b5        //101
	b6 = iota //5
)
const (
	_  = iota
	KB = 1 << (10 * iota)
	MB = 1 << (10 * iota)
	GB = 1 << (10 * iota)
	TB = 1 << (10 * iota)
)

//全局变量可以声明不使用，但是函数内的变量必须声明
func PrintCon() {

	fmt.Println("a1:", a1)
	fmt.Println("a2:", a2)
	fmt.Println("a3:", a3)
	fmt.Println("a4:", a4)
	fmt.Println("b1:", b1) //100
	fmt.Println("b2:", b2) //1
	fmt.Println("b3:", b3) //2
	fmt.Println("b4:", b4) //101
	fmt.Println("b5:", b5)
	fmt.Println("b6:", b6)

}
-------------------------------------------------------------
a1: 100
a2: 100
a3: 100
a4: 3
b1: 100
b2: 1
b3: 2
b4: 101
b5: 101
b6: 5
```




## 语法 
### 分支  
### 循环
### 跳转 

## 数据结构  
### 基础数据类型  
#### int 
| 类型   | 范围                           | 内存大小             |
|--------|--------------------------------|----------------------|
| int8   | 0~2^8-1(0~255)                 | 1                    |
| int16  | 0~2^16-1(0~65535)              | 2                    |
| int32  | 0~2^32-1(0~4294967295)         | 4                    |
| int64  | 0~2^64(0~18446744073709551615) | 8                    |
| uint8  | (-127~127)                     | 1                    |
| uint16 | (-32767~32767)                 | 2                    |
| uint32 | (-2147483648~2147483648)       | 4                    |
| uint64 |                                | 8                    |
| int    |                                | 根据系统位数自动定位 |
| uint   |                                | 根据系统位数自动定位 |

```
func main() {
	i := 20
	fmt.Printf("i1类型%T\n", i)
	fmt.Printf("i1二进制%b\n", i)
	fmt.Printf("i1十进制%d\n", i)
	fmt.Printf("i1八进制%o\n", i)
	fmt.Printf("i1十六进制%x\n", i)
	i2 := 011
	fmt.Printf("i2类型%T\n", i2)
	fmt.Printf("i2二进制%b\n", i2)
	fmt.Printf("i2十进制%d\n", i2)
	fmt.Printf("i2八进制%o\n", i2)
	fmt.Printf("i2十六进制%x\n", i2)
	i3 := 0x11
	fmt.Printf("i3类型%T\n", i3)
	fmt.Printf("i3二进制%b\n", i3)
	fmt.Printf("i3十进制%d\n", i3)
	fmt.Printf("i3八进制%o\n", i3)
	fmt.Printf("i3十六进制%x\n", i3)

	i4 := int32(i)
	fmt.Printf("i4类型%T\n", i4)
	fmt.Printf("i4二进制%b\n", i4)
	fmt.Printf("i4十进制%d\n", i4)
	fmt.Printf("i4八进制%o\n", i4)
	fmt.Printf("i4十六进制%x\n", i4)
	//字面量语法
	i5 := 0b10011
	fmt.Printf("i5类型%T\n", i5)
	fmt.Printf("i5二进制%b\n", i5)
	fmt.Printf("i5十进制%d\n", i5)
	fmt.Printf("i5八进制%o\n", i5)
	fmt.Printf("i5十六进制%x\n", i5)
	//字面量语法
	i6 := 0o11
	fmt.Printf("i6类型%T\n", i6)
	fmt.Printf("i6二进制%b\n", i6)
	fmt.Printf("i6十进制%d\n", i6)
	fmt.Printf("i6八进制%o\n", i6)
	fmt.Printf("i6十六进制%x\n", i6)
	//字面量语法
	i7 := 0x11
	fmt.Printf("i7类型%T\n", i7)
	fmt.Printf("i7二进制%b\n", i7)
	fmt.Printf("i7十进制%d\n", i7)
	fmt.Printf("i7八进制%o\n", i7)
	fmt.Printf("i7十六进制%x\n", i7)
}
----------------------------------------------------------
i1类型int
i1二进制10100
i1十进制20
i1八进制24
i1十六进制14
i2类型int
i2二进制1001
i2十进制9
i2八进制11
i2十六进制9
i3类型int
i3二进制10001
i3十进制17
i3八进制21
i3十六进制11
i4类型int32
i4二进制10100
i4十进制20
i4八进制24
i4十六进制14
i5类型int
i5二进制10011
i5十进制19
i5八进制23
i5十六进制13
i6类型int
i6二进制1001
i6十进制9
i6八进制11
i6十六进制9
i7类型int
i7二进制10001
i7十进制17
i7八进制21
i7十六进制11

```
#### float  
| 类型    | 范围                 | 内存大小 |
|---------|----------------------|----------|
| float32 | -3.403e38~3.403e38   | 4        |
| float64 | -1.798e308~1.798e308 | 8        |

#### bool
| 类型 | 范围  | 内存大小 |
|------|-------|----------|
| bool | true  | 1        |
| bool | false | 1        |
- bool值默认为false  
- go中不允许将整形转成bool型 
- 布尔型无法参与数值运算，也无法与其他类型进行转换
#### string   
  字符串是由字符组成一个串。  
  字符串不可变，想改变某个字符需要转换成byte切片或者rune切片。
  字符串特殊字符可以用转义字符表示，也可以用``来表示，不需要转义
  字符串拼接用+或者+=，一个字符串过长换行时+需要放在上一行。
  byte本质上是int8,rune本质上是int32,一个汉字一般占3个字节 
#### string常用包 
#### 数据类型转换 
 ##### 整数浮点数数据转换  
 - go语言不存隐式转换，所有的类型转换都需要显式转换  
 - 转换的时候，会有溢出现象，但不会报错  
 ##### 其他转string  
 ```//int2str
	i1 := 55
	s1 := fmt.Sprintf("%d", i1)
	//float2str
	f1 := 5.5555
	ss1 := fmt.Sprintf("%.3f", f1)
	fmt.Printf("s1 %T value %s ;ss1 %T value %s\n", s1, s1, ss1, ss1)
	s2 := strconv.Itoa(i1)
	ss2 := strconv.FormatFloat(f1, 'f', 3, 64)
	fmt.Printf("s2 %T value %s; ss2 %T value %s\n", s2, s2, ss2, ss2)
	//bool2str
	b1 := true
	sb1 := fmt.Sprintf("%t", b1)
	ssb1 := strconv.FormatBool(b1)
	fmt.Printf("sb1 %T value %s; ssb1 %T value %s\n", sb1, sb1, ssb1, ssb1)
 ```
 ##### string转其他
### 数组
### 切片 slice
### 映射 map
### 指针
### 结构体 struct 
### 接口 interface 
### 管道 channel
### 协程 goroutine
## 总结 






 


    

  
